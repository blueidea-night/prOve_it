{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/server/api.js","filenameRelative":"/server/api.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/server/api.js.map","sourceFileName":"/server/api.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"api"},"ignored":false,"code":"Router.route('/', function () {\n  // Two parts here. Oof. So, our friend CORS is fussy. In order to get our\n  // request through, we need to do two things: let it know that the request\n  // is allowed from the originating server AND, let it know what options it\n  // is allowed to send with the request.\n\n  // There are two types of requests happening: OPTIONS and the actual request.\n  // An OPTIONS request is known as a \"pre-flight\" request. Before the actual\n  // request is run, it will ask if it is allowed to make the request, AND,\n  // if the data it's asking to pass over is allowed.\n\n  // Setting Access-Control-Allow-Origin answers the first question, by saying\n  // what domains requests are allowed to be made from (in this case * is equal\n  // to saying \"anywhere\").\n  this.response.setHeader('Access-Control-Allow-Origin', '*');\n\n  // Here, we check the request method to see if it's an OPTIONS request, or,\n  // a pre-flight check. If it is, we pass along a list of allowed headers and\n  // methods, followed by an end to that request (the pre-flight). Once this is\n  // received by the requesting server, it will attempt to perform the actual\n  // request (GET, POST, PUT, or DELETE).\n  if (this.request.method === \"OPTIONS\") {\n    this.response.setHeader('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');\n    this.response.setHeader('Access-Control-Allow-Methods', 'POST, PUT, GET, DELETE, OPTIONS');\n    this.response.end('Set OPTIONS.');\n  } else {\n    // If we've already passed through the OPTIONS request, we go ahead and call\n    // our actual HTTP method.\n    API.handleRequest(this, this.request.method);\n  }\n}, { where: 'server' });\n\nAPI = {\n  connection: function () {\n    function connection(request) {\n      var getRequestContents = API.utility.getRequestContents(request);\n      return { data: getRequestContents };\n    }\n\n    return connection;\n  }(),\n  handleRequest: function () {\n    function handleRequest(context, method) {\n      var connection = API.connection(context.request);\n      if (!connection.error) {\n        API.methods[method](context, connection);\n      } else {\n        API.utility.response(context, 401, connection);\n      }\n    }\n\n    return handleRequest;\n  }(),\n  methods: {\n    GET: function () {\n      function GET(context, connection) {\n        // Check to see if our request has any data. If it doesn't, we want to\n        // return all pizzas for the owner. If it does, we want to search for\n        // pizzas matching that query.\n        var hasData = API.utility.hasData(connection.data),\n\n        // the validation does nothing at the moment\n        validData = API.utility.validate(connection.data, { \"a\": String, \"b\": String });\n\n        if (hasData && validData) {\n          var total = MATH.add(parseInt(connection.data['a']), parseInt(connection.data['b']));\n          API.utility.response(context, 200, {\n            a: connection.data['a'],\n            b: connection.data['b'],\n\n            total: total\n          });\n        } else {\n          API.utility.response(context, 404, { error: 404, message: \"No numbers found, dude.\" });\n        }\n      }\n\n      return GET;\n    }(),\n    POST: function () {\n      function POST(context, connection) {\n        // Make sure that our request has data and that the data is valid.\n        var hasData = API.utility.hasData(connection.data),\n\n        // the validation does nothing at the moment\n        validData = API.utility.validate(connection.data, { \"a\": String, \"b\": String });\n\n        if (hasData && validData) {\n          var total = MATH.add(parseInt(connection.data['a']), parseInt(connection.data['b']));\n          API.utility.response(context, 200, {\n            a: connection.data['a'],\n            b: connection.data['b'],\n\n            total: total\n          });\n        } else {\n          API.utility.response(context, 404, { error: 404, message: \"No numbers found, dude.\" });\n        }\n      }\n\n      return POST;\n    }()\n  },\n  // PUT: function( context, connection ) {\n  //   var hasQuery  = API.utility.hasData( connection.data ),\n  //       validData = API.utility.validate( connection.data, Match.OneOf(\n  //         { \"_id\": String, \"name\": String },\n  //         { \"_id\": String, \"crust\": String },\n  //         { \"_id\": String, \"toppings\": [ String ] },\n  //         { \"_id\": String, \"name\": String, \"crust\": String },\n  //         { \"_id\": String, \"name\": String, \"toppings\": [ String ] },\n  //         { \"_id\": String, \"crust\": String, \"toppings\": [ String ] },\n  //         { \"_id\": String, \"name\": String, \"crust\": String, \"toppings\": [ String ] }\n  //       ));\n\n  //   if ( hasQuery && validData ) {\n  //     // Save the ID of the pizza we want to update and then sanatize our\n  //     // data so that it only includes name, crust, and toppings parameters.\n  //     var pizzaId = connection.data._id;\n  //     delete connection.data._id;\n\n  //     var getPizza = Pizza.findOne( { \"_id\": pizzaId }, { fields: { \"_id\": 1 } } );\n\n  //     if ( getPizza ) {\n  //       Pizza.update( { \"_id\": pizzaId }, { $set: connection.data } );\n  //       API.utility.response( context, 200, { \"message\": \"Pizza successfully updated!\" } );\n  //     } else {\n  //       API.utility.response( context, 404, { \"message\": \"Can't update a non-existent pizza, homeslice.\" } );\n  //     }\n  //   } else {\n  //     API.utility.response( context, 403, { error: 403, message: \"PUT calls must have a pizza ID and at least a name, crust, or toppings passed in the request body in the correct formats (String, String, Array).\" } );\n  //   }\n  // },\n  // DELETE: function( context, connection ) {\n  //   var hasQuery  = API.utility.hasData( connection.data ),\n  //       validData = API.utility.validate( connection.data, { \"_id\": String } );\n\n  //   if ( hasQuery && validData ) {\n  //     var pizzaId  = connection.data._id;\n  //     var getPizza = Pizza.findOne( { \"_id\": pizzaId }, { fields: { \"_id\": 1 } } );\n\n  //     if ( getPizza ) {\n  //       Pizza.remove( { \"_id\": pizzaId } );\n  //       API.utility.response( context, 200, { \"message\": \"Pizza removed!\" } );\n  //     } else {\n  //       API.utility.response( context, 404, { \"message\": \"Can't delete a non-existent pizza, homeslice.\" } );\n  //     }\n  //   } else {\n  //     API.utility.response( context, 403, { error: 403, message: \"DELETE calls must have an _id (and only an _id) in the request body in the correct format (String).\" } );\n  //   }\n  // }\n  utility: {\n    getRequestContents: function () {\n      function getRequestContents(request) {\n        return request.query;\n        // switch( request.method ) {\n        //   case \"GET\":\n        //     return request.query;\n        //   case \"POST\":\n        //   case \"PUT\":\n        //   case \"DELETE\":\n        //     return request.body;\n        // }\n      }\n\n      return getRequestContents;\n    }(),\n    hasData: function () {\n      function hasData(data) {\n        return Object.keys(data).length > 1 ? true : false;\n        // return true;\n      }\n\n      return hasData;\n    }(),\n    response: function () {\n      function response(context, statusCode, data) {\n        context.response.setHeader('Content-Type', 'application/json');\n        context.response.statusCode = statusCode;\n        context.response.end(JSON.stringify(data));\n      }\n\n      return response;\n    }(),\n    validate: function () {\n      function validate(data, pattern) {\n        return true;\n        return Match.test(data, pattern);\n      }\n\n      return validate;\n    }()\n  }\n};","ast":null,"map":{"version":3,"sources":["/server/api.js"],"names":[],"mappings":"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","file":"/server/api.js.map","sourcesContent":["Router.route( '/', function() {\n  // Two parts here. Oof. So, our friend CORS is fussy. In order to get our\n  // request through, we need to do two things: let it know that the request\n  // is allowed from the originating server AND, let it know what options it\n  // is allowed to send with the request.\n\n  // There are two types of requests happening: OPTIONS and the actual request.\n  // An OPTIONS request is known as a \"pre-flight\" request. Before the actual\n  // request is run, it will ask if it is allowed to make the request, AND,\n  // if the data it's asking to pass over is allowed.\n\n  // Setting Access-Control-Allow-Origin answers the first question, by saying\n  // what domains requests are allowed to be made from (in this case * is equal\n  // to saying \"anywhere\").\n  this.response.setHeader( 'Access-Control-Allow-Origin', '*' );\n\n  // Here, we check the request method to see if it's an OPTIONS request, or,\n  // a pre-flight check. If it is, we pass along a list of allowed headers and\n  // methods, followed by an end to that request (the pre-flight). Once this is\n  // received by the requesting server, it will attempt to perform the actual\n  // request (GET, POST, PUT, or DELETE).\n  if ( this.request.method === \"OPTIONS\" ) {\n    this.response.setHeader( 'Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept' );\n    this.response.setHeader( 'Access-Control-Allow-Methods', 'POST, PUT, GET, DELETE, OPTIONS' );\n    this.response.end( 'Set OPTIONS.' );\n  } else {\n    // If we've already passed through the OPTIONS request, we go ahead and call\n    // our actual HTTP method.\n    API.handleRequest( this, this.request.method );\n  }\n}, { where: 'server' } );\n\nAPI = {\n  connection: function( request ) {\n    var getRequestContents = API.utility.getRequestContents( request );\n    return { data: getRequestContents };\n  },\n  handleRequest: function( context, method ) {\n    var connection = API.connection( context.request );\n    if ( !connection.error ) {\n      API.methods[ method ]( context, connection );\n    } else {\n      API.utility.response( context, 401, connection );\n    }\n  },\n  methods: {\n      GET: function( context, connection ) {\n      // Check to see if our request has any data. If it doesn't, we want to\n      // return all pizzas for the owner. If it does, we want to search for\n      // pizzas matching that query.\n      var hasData   = API.utility.hasData( connection.data ),\n          // the validation does nothing at the moment\n          validData = API.utility.validate( connection.data, { \"a\": String, \"b\": String });\n\n\n          if ( hasData && validData ) {\n              var total = MATH.add(parseInt(connection.data['a']),parseInt(connection.data['b']));\n              API.utility.response( context, 200, {\n                  a: connection.data['a'],\n                  b: connection.data['b'],\n\n                  total: total\n              });\n          } else {\n              API.utility.response( context, 404, { error: 404, message: \"No numbers found, dude.\" } );\n          }\n      },\n    POST: function( context, connection ) {\n      // Make sure that our request has data and that the data is valid.\n      var hasData   = API.utility.hasData( connection.data ),\n          // the validation does nothing at the moment\n          validData = API.utility.validate( connection.data, { \"a\": String, \"b\": String });\n\n      if ( hasData && validData ) {\n        var total = MATH.add(parseInt(connection.data['a']),parseInt(connection.data['b']));\n        API.utility.response( context, 200, {\n          a: connection.data['a'],\n          b: connection.data['b'],\n\n          total: total\n        });\n      } else {\n          API.utility.response( context, 404, { error: 404, message: \"No numbers found, dude.\" } );\n      }\n    },\n    // PUT: function( context, connection ) {\n    //   var hasQuery  = API.utility.hasData( connection.data ),\n    //       validData = API.utility.validate( connection.data, Match.OneOf(\n    //         { \"_id\": String, \"name\": String },\n    //         { \"_id\": String, \"crust\": String },\n    //         { \"_id\": String, \"toppings\": [ String ] },\n    //         { \"_id\": String, \"name\": String, \"crust\": String },\n    //         { \"_id\": String, \"name\": String, \"toppings\": [ String ] },\n    //         { \"_id\": String, \"crust\": String, \"toppings\": [ String ] },\n    //         { \"_id\": String, \"name\": String, \"crust\": String, \"toppings\": [ String ] }\n    //       ));\n\n    //   if ( hasQuery && validData ) {\n    //     // Save the ID of the pizza we want to update and then sanatize our\n    //     // data so that it only includes name, crust, and toppings parameters.\n    //     var pizzaId = connection.data._id;\n    //     delete connection.data._id;\n\n    //     var getPizza = Pizza.findOne( { \"_id\": pizzaId }, { fields: { \"_id\": 1 } } );\n\n    //     if ( getPizza ) {\n    //       Pizza.update( { \"_id\": pizzaId }, { $set: connection.data } );\n    //       API.utility.response( context, 200, { \"message\": \"Pizza successfully updated!\" } );\n    //     } else {\n    //       API.utility.response( context, 404, { \"message\": \"Can't update a non-existent pizza, homeslice.\" } );\n    //     }\n    //   } else {\n    //     API.utility.response( context, 403, { error: 403, message: \"PUT calls must have a pizza ID and at least a name, crust, or toppings passed in the request body in the correct formats (String, String, Array).\" } );\n    //   }\n    // },\n    // DELETE: function( context, connection ) {\n    //   var hasQuery  = API.utility.hasData( connection.data ),\n    //       validData = API.utility.validate( connection.data, { \"_id\": String } );\n\n    //   if ( hasQuery && validData ) {\n    //     var pizzaId  = connection.data._id;\n    //     var getPizza = Pizza.findOne( { \"_id\": pizzaId }, { fields: { \"_id\": 1 } } );\n\n    //     if ( getPizza ) {\n    //       Pizza.remove( { \"_id\": pizzaId } );\n    //       API.utility.response( context, 200, { \"message\": \"Pizza removed!\" } );\n    //     } else {\n    //       API.utility.response( context, 404, { \"message\": \"Can't delete a non-existent pizza, homeslice.\" } );\n    //     }\n    //   } else {\n    //     API.utility.response( context, 403, { error: 403, message: \"DELETE calls must have an _id (and only an _id) in the request body in the correct format (String).\" } );\n    //   }\n    // }\n  },\n  utility: {\n    getRequestContents: function( request ) {\n      return request.query;\n      // switch( request.method ) {\n      //   case \"GET\":\n      //     return request.query;\n      //   case \"POST\":\n      //   case \"PUT\":\n      //   case \"DELETE\":\n      //     return request.body;\n      // }\n    },\n    hasData: function( data ) {\n      return Object.keys( data ).length > 1 ? true : false;\n      // return true;\n    },\n    response: function( context, statusCode, data ) {\n      context.response.setHeader( 'Content-Type', 'application/json' );\n      context.response.statusCode = statusCode;\n      context.response.end( JSON.stringify( data ) );\n    },\n    validate: function( data, pattern ) {\n      return true;\n      return Match.test( data, pattern );\n    }\n  }\n};\n"]},"hash":"c7fab9f72b51bfe0460daa34b927bc6057e38ed1"}
